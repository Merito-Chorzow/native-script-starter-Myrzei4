import { Application, Device, Trace, Utils } from '@nativescript/core';
import { CLog, CLogTypes } from './index.common';
export * from './index.common';
export var PermissionsIOS;
(function (PermissionsIOS) {
    let Status;
    (function (Status) {
        Status["Undetermined"] = "undetermined";
        Status["Denied"] = "denied";
        Status["Authorized"] = "authorized";
        Status["Limited"] = "limited";
        Status["Restricted"] = "restricted";
    })(Status = PermissionsIOS.Status || (PermissionsIOS.Status = {}));
    let NSPLocation;
    (function (NSPLocation) {
        let status = Status.Undetermined;
        function getStatusFromCLAuthorizationStatus(lStatus, type) {
            let always = false;
            switch (lStatus) {
                case 3 /* CLAuthorizationStatus.kCLAuthorizationStatusAuthorizedAlways */:
                    always = true;
                    status = Status.Authorized;
                    break;
                case 4 /* CLAuthorizationStatus.kCLAuthorizationStatusAuthorizedWhenInUse */:
                    status = Status.Authorized;
                    break;
                case 2 /* CLAuthorizationStatus.kCLAuthorizationStatusDenied */:
                    status = Status.Denied;
                    break;
                case 1 /* CLAuthorizationStatus.kCLAuthorizationStatusRestricted */:
                    status = Status.Restricted;
                    break;
                default:
                    status = Status.Undetermined;
            }
            if (Trace.isEnabled()) {
                CLog(CLogTypes.info, 'NSPLocation getStatusFromCLAuthorizationStatus', lStatus, type, status, always);
            }
            return [status, always];
        }
        function getStatusForType(type) {
            const status2 = CLLocationManager.authorizationStatus();
            return getStatusFromCLAuthorizationStatus(status2, type);
        }
        NSPLocation.getStatusForType = getStatusForType;
        let locationManager;
        let locationManagerDelegate;
        var CLLocationManagerDelegateImpl = /** @class */ (function (_super) {
    __extends(CLLocationManagerDelegateImpl, _super);
    function CLLocationManagerDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CLLocationManagerDelegateImpl.prototype.addSubDelegate = function (delegate) {
        if (!this.subDelegates) {
            this.subDelegates = [];
        }
        var index = this.subDelegates.indexOf(delegate);
        if (index === -1) {
            this.subDelegates.push(delegate);
        }
    };
    CLLocationManagerDelegateImpl.prototype.removeSubDelegate = function (delegate) {
        var index = this.subDelegates.indexOf(delegate);
        if (index !== -1) {
            this.subDelegates.splice(index, 1);
        }
    };
    CLLocationManagerDelegateImpl.new = function () {
        return _super.new.call(this);
    };
    CLLocationManagerDelegateImpl.prototype.initDelegate = function () {
        this.subDelegates = [];
        return this;
    };
    CLLocationManagerDelegateImpl.prototype.locationManagerDidChangeAuthorizationStatus = function (manager, status) {
        this.subDelegates &&
            this.subDelegates.forEach(function (d) {
                if (d.locationManagerDidChangeAuthorizationStatus) {
                    d.locationManagerDidChangeAuthorizationStatus(manager, status);
                }
            });
    };
    CLLocationManagerDelegateImpl.ObjCProtocols = [CLLocationManagerDelegate];
    return CLLocationManagerDelegateImpl;
}(NSObject));
        async function request(type) {
            const status = getStatusForType(type);
            if (Trace.isEnabled()) {
                CLog(CLogTypes.info, 'NSPLocation request', type, status);
            }
            if (status[0] === Status.Undetermined || status[0] === Status.Denied || (type === 'always' && !status[1])) {
                return new Promise((resolve, reject) => {
                    if (!locationManager) {
                        locationManager = CLLocationManager.new();
                    }
                    if (!locationManagerDelegate) {
                        locationManagerDelegate = CLLocationManagerDelegateImpl.new().initDelegate();
                        locationManager.delegate = locationManagerDelegate;
                    }
                    function cleanup() {
                        if (locationManagerDelegate) {
                            locationManagerDelegate.removeSubDelegate(subD);
                            locationManagerDelegate = null;
                        }
                        if (locationManager) {
                            locationManager.delegate = null;
                            // locationManager = null;
                        }
                    }
                    const subD = {
                        locationManagerDidChangeAuthorizationStatus: (manager, status) => {
                            if (Trace.isEnabled()) {
                                CLog(CLogTypes.info, 'locationManagerDidChangeAuthorizationStatus', status);
                            }
                            if (status !== 0 /* CLAuthorizationStatus.kCLAuthorizationStatusNotDetermined */) {
                                const rStatus = getStatusFromCLAuthorizationStatus(status, type);
                                resolve(rStatus);
                                cleanup();
                            }
                        }
                    };
                    locationManagerDelegate.addSubDelegate(subD);
                    try {
                        if (Trace.isEnabled()) {
                            CLog(CLogTypes.info, 'NSPLocation requestAuthorization', type);
                        }
                        if (type === 'always') {
                            locationManager.requestAlwaysAuthorization();
                        }
                        else {
                            locationManager.requestWhenInUseAuthorization();
                        }
                    }
                    catch (e) {
                        reject(e);
                        cleanup();
                    }
                });
            }
            else {
                return status;
            }
        }
        NSPLocation.request = request;
    })(NSPLocation || (NSPLocation = {}));
    let NSPBluetooth;
    (function (NSPBluetooth) {
        let status = Status.Undetermined;
        function getStatus() {
            const status2 = CBPeripheralManager.authorizationStatus();
            switch (status2) {
                case 3 /* CBPeripheralManagerAuthorizationStatus.Authorized */:
                    status = Status.Authorized;
                    break;
                case 2 /* CBPeripheralManagerAuthorizationStatus.Denied */:
                    status = Status.Denied;
                    break;
                case 1 /* CBPeripheralManagerAuthorizationStatus.Restricted */:
                    status = Status.Restricted;
                    break;
                default:
                    status = Status.Undetermined;
            }
            return [status, true];
        }
        NSPBluetooth.getStatus = getStatus;
        var CBPeripheralManagerDelegateImpl = /** @class */ (function (_super) {
    __extends(CBPeripheralManagerDelegateImpl, _super);
    function CBPeripheralManagerDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CBPeripheralManagerDelegateImpl.prototype.addSubDelegate = function (delegate) {
        var index = this.subDelegates.indexOf(delegate);
        if (index === -1) {
            this.subDelegates.push(delegate);
        }
    };
    CBPeripheralManagerDelegateImpl.prototype.removeSubDelegate = function (delegate) {
        var index = this.subDelegates.indexOf(delegate);
        if (index !== -1) {
            this.subDelegates.splice(index, 1);
        }
    };
    CBPeripheralManagerDelegateImpl.new = function () {
        return _super.new.call(this);
    };
    CBPeripheralManagerDelegateImpl.prototype.initDelegate = function () {
        this.subDelegates = [];
        return this;
    };
    CBPeripheralManagerDelegateImpl.prototype.peripheralManagerDidUpdateState = function (peripheralManager) {
        this.subDelegates.forEach(function (d) {
            if (d.peripheralManagerDidUpdateState) {
                d.peripheralManagerDidUpdateState(peripheralManager);
            }
        });
    };
    CBPeripheralManagerDelegateImpl.ObjCProtocols = [CBPeripheralManagerDelegate];
    return CBPeripheralManagerDelegateImpl;
}(NSObject));
        let peripheralManager;
        function request() {
            const status = getStatus();
            if (status[0] === Status.Undetermined || status[0] === Status.Denied) {
                return new Promise((resolve, reject) => {
                    if (!peripheralManager) {
                        peripheralManager = CBPeripheralManager.new();
                        peripheralManager.delegate = CBPeripheralManagerDelegateImpl.new().initDelegate();
                    }
                    const subD = {
                        peripheralManagerDidUpdateState: (peripheralManager) => {
                            if (peripheralManager) {
                                peripheralManager.stopAdvertising();
                                peripheralManager.delegate.removeSubDelegate(subD);
                                peripheralManager.delegate = null;
                                peripheralManager = null;
                            }
                            // for some reason, checking permission right away returns denied. need to wait a tiny bit
                            setTimeout(() => {
                                resolve(getStatus());
                            }, 100);
                        }
                    };
                    peripheralManager.delegate.addSubDelegate(subD);
                    try {
                        peripheralManager.startAdvertising(null);
                    }
                    catch (e) {
                        reject(e);
                    }
                });
            }
            else {
                return Promise.resolve(status);
            }
        }
        NSPBluetooth.request = request;
    })(NSPBluetooth || (NSPBluetooth = {}));
    let NSPAudioVideo;
    (function (NSPAudioVideo) {
        let status = Status.Undetermined;
        function typeFromString(value) {
            if (value === 'audio') {
                return AVMediaTypeAudio;
            }
            else {
                return AVMediaTypeVideo;
            }
        }
        function getStatus(type) {
            const videoStatus = AVCaptureDevice.authorizationStatusForMediaType(typeFromString(type));
            switch (videoStatus) {
                case 3 /* AVAuthorizationStatus.Authorized */:
                    status = Status.Authorized;
                    break;
                case 2 /* AVAuthorizationStatus.Denied */:
                    status = Status.Denied;
                    break;
                case 1 /* AVAuthorizationStatus.Restricted */:
                    status = Status.Restricted;
                    break;
                default:
                    status = Status.Undetermined;
            }
            return [status, true];
        }
        NSPAudioVideo.getStatus = getStatus;
        function request(type) {
            return new Promise((resolve, reject) => {
                AVCaptureDevice.requestAccessForMediaTypeCompletionHandler(typeFromString(type), (granted) => resolve(getStatus(type)));
            });
        }
        NSPAudioVideo.request = request;
    })(NSPAudioVideo || (NSPAudioVideo = {}));
    let NSPSpeechRecognition;
    (function (NSPSpeechRecognition) {
        let status = Status.Undetermined;
        function getStatus() {
            const speechStatus = SFSpeechRecognizer.authorizationStatus();
            switch (speechStatus) {
                case 3 /* SFSpeechRecognizerAuthorizationStatus.Authorized */:
                    status = Status.Authorized;
                    break;
                case 1 /* SFSpeechRecognizerAuthorizationStatus.Denied */:
                    status = Status.Denied;
                    break;
                case 2 /* SFSpeechRecognizerAuthorizationStatus.Restricted */:
                    status = Status.Restricted;
                    break;
                default:
                    status = Status.Undetermined;
            }
            return [status, true];
        }
        NSPSpeechRecognition.getStatus = getStatus;
        function request() {
            return new Promise((resolve) => {
                SFSpeechRecognizer.requestAuthorization(() => resolve(getStatus()));
            });
        }
        NSPSpeechRecognition.request = request;
    })(NSPSpeechRecognition || (NSPSpeechRecognition = {}));
    let NSPPhoto;
    (function (NSPPhoto) {
        let status = Status.Undetermined;
        function getStatus() {
            let photoStatus;
            if (parseFloat(Device.osVersion) >= 14) {
                photoStatus = PHPhotoLibrary.authorizationStatusForAccessLevel(2 /* PHAccessLevel.ReadWrite */);
            }
            else {
                photoStatus = PHPhotoLibrary.authorizationStatus();
            }
            switch (photoStatus) {
                case 4 /* PHAuthorizationStatus.Limited */:
                    status = Status.Limited;
                    break;
                case 3 /* PHAuthorizationStatus.Authorized */:
                    status = Status.Authorized;
                    break;
                case 2 /* PHAuthorizationStatus.Denied */:
                    status = Status.Denied;
                    break;
                case 1 /* PHAuthorizationStatus.Restricted */:
                    status = Status.Restricted;
                    break;
                default:
                    status = Status.Undetermined;
            }
            return [status, true];
        }
        NSPPhoto.getStatus = getStatus;
        function request() {
            return new Promise((resolve) => {
                PHPhotoLibrary.requestAuthorization(() => resolve(getStatus()));
            });
        }
        NSPPhoto.request = request;
    })(NSPPhoto || (NSPPhoto = {}));
    let NSPMotion;
    (function (NSPMotion) {
        let status = Status.Undetermined;
        function getStatus() {
            if (status === Status.Undetermined) {
                const cmStatus = CMMotionActivityManager.authorizationStatus();
                switch (cmStatus) {
                    case 3 /* CMAuthorizationStatus.Authorized */:
                        status = Status.Authorized;
                        break;
                    case 2 /* CMAuthorizationStatus.Denied */:
                        status = Status.Denied;
                        break;
                    case 1 /* CMAuthorizationStatus.Restricted */:
                        status = Status.Restricted;
                        break;
                }
            }
            return [status, true];
        }
        NSPMotion.getStatus = getStatus;
        async function request() {
            const status = getStatus();
            if (status[0] === Status.Undetermined || status[0] === Status.Denied) {
                await new Promise((resolve, reject) => {
                    let activityManager = CMMotionActivityManager.new();
                    let motionActivityQueue = NSOperationQueue.new();
                    if (Trace.isEnabled()) {
                        CLog(CLogTypes.info, 'NSPMotion request', status);
                    }
                    activityManager.queryActivityStartingFromDateToDateToQueueWithHandler(NSDate.distantPast, new Date(), motionActivityQueue, (activities, error) => {
                        if (Trace.isEnabled()) {
                            CLog(CLogTypes.info, 'NSPMotion got response', activities, error, status, getStatus());
                        }
                        if (error) {
                            reject(error);
                        }
                        else {
                            resolve();
                        }
                        activityManager = null;
                        motionActivityQueue = null;
                    });
                });
                return getStatus();
            }
            else {
                return status;
            }
        }
        NSPMotion.request = request;
    })(NSPMotion || (NSPMotion = {}));
    let NSPMediaLibrary;
    (function (NSPMediaLibrary) {
        let status = Status.Undetermined;
        function getStatus() {
            const mediaStatus = MPMediaLibrary.authorizationStatus();
            switch (mediaStatus) {
                case 3 /* MPMediaLibraryAuthorizationStatus.Authorized */:
                    status = Status.Authorized;
                    break;
                case 1 /* MPMediaLibraryAuthorizationStatus.Denied */:
                    status = Status.Denied;
                    break;
                case 2 /* MPMediaLibraryAuthorizationStatus.Restricted */:
                    status = Status.Restricted;
                    break;
                default:
                    status = Status.Undetermined;
            }
            return [status, true];
        }
        NSPMediaLibrary.getStatus = getStatus;
        function request() {
            return new Promise((resolve) => {
                MPMediaLibrary.requestAuthorization(() => resolve(getStatus()));
            });
        }
        NSPMediaLibrary.request = request;
    })(NSPMediaLibrary || (NSPMediaLibrary = {}));
    let NSPNotification;
    (function (NSPNotification) {
        let status = Status.Undetermined;
        const NSPDidAskForNotification = 'NSPDidAskForNotification';
        async function getStatus() {
            const didAskForPermission = NSUserDefaults.standardUserDefaults.boolForKey(NSPDidAskForNotification);
            let isEnabled = false;
            const osVersion = parseFloat(Device.osVersion);
            if (osVersion >= 10) {
                const test = await new Promise((resolve) => UNUserNotificationCenter.currentNotificationCenter().getNotificationSettingsWithCompletionHandler(resolve));
                isEnabled = test.authorizationStatus === 2 /* UNAuthorizationStatus.Authorized */;
            }
            else {
                isEnabled = UIApplication.sharedApplication.currentUserNotificationSettings.types !== 0 /* UIUserNotificationType.None */;
            }
            if (isEnabled) {
                status = Status.Authorized;
            }
            else {
                status = didAskForPermission ? Status.Denied : Status.Undetermined;
            }
            return [status, true];
        }
        NSPNotification.getStatus = getStatus;
        async function request(types = 4 /* UNAuthorizationOptions.Alert */) {
            const status = await getStatus();
            if (status[0] === Status.Undetermined || status[0] === Status.Denied) {
                await new Promise((resolve, reject) => {
                    Utils.dispatchToMainThread(() => {
                        const osVersion = parseFloat(Device.osVersion);
                        if (osVersion >= 10) {
                            UNUserNotificationCenter.currentNotificationCenter().requestAuthorizationWithOptionsCompletionHandler(types, (p1, error) => {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    UIApplication.sharedApplication.registerForRemoteNotifications();
                                    resolve();
                                }
                            });
                        }
                        else {
                            const settings = UIUserNotificationSettings.settingsForTypesCategories(types, null);
                            UIApplication.sharedApplication.registerUserNotificationSettings(settings);
                            UIApplication.sharedApplication.registerForRemoteNotifications();
                            resolve();
                        }
                    });
                });
                NSUserDefaults.standardUserDefaults.setBoolForKey(true, NSPDidAskForNotification);
                NSUserDefaults.standardUserDefaults.synchronize();
                return getStatus();
            }
            else {
                return status;
            }
        }
        NSPNotification.request = request;
    })(NSPNotification || (NSPNotification = {}));
    let NSPContacts;
    (function (NSPContacts) {
        let status = Status.Undetermined;
        function getStatus() {
            const contactStatus = CNContactStore.authorizationStatusForEntityType(0 /* CNEntityType.Contacts */);
            switch (contactStatus) {
                case 3 /* CNAuthorizationStatus.Authorized */:
                    status = Status.Authorized;
                    break;
                case 2 /* CNAuthorizationStatus.Denied */:
                    status = Status.Denied;
                    break;
                case 1 /* CNAuthorizationStatus.Restricted */:
                    status = Status.Restricted;
                    break;
                default:
                    status = Status.Undetermined;
            }
            return [status, true];
        }
        NSPContacts.getStatus = getStatus;
        function request() {
            return new Promise((resolve) => {
                const contactStore = CNContactStore.new();
                contactStore.requestAccessForEntityTypeCompletionHandler(0 /* CNEntityType.Contacts */, () => resolve(getStatus()));
            });
        }
        NSPContacts.request = request;
    })(NSPContacts || (NSPContacts = {}));
    let NSPBackgroundRefresh;
    (function (NSPBackgroundRefresh) {
        let status = Status.Undetermined;
        function getStatus() {
            const refreshStatus = UIApplication.sharedApplication.backgroundRefreshStatus;
            switch (refreshStatus) {
                case 2 /* UIBackgroundRefreshStatus.Available */:
                    status = Status.Authorized;
                    break;
                case 1 /* UIBackgroundRefreshStatus.Denied */:
                    status = Status.Denied;
                    break;
                case 0 /* UIBackgroundRefreshStatus.Restricted */:
                    status = Status.Restricted;
                    break;
                default:
                    status = Status.Undetermined;
            }
            return [status, true];
        }
        NSPBackgroundRefresh.getStatus = getStatus;
        function request() {
            return new Promise((resolve) => {
                const contactStore = CNContactStore.new();
                contactStore.requestAccessForEntityTypeCompletionHandler(0 /* CNEntityType.Contacts */, () => resolve(getStatus()[0]));
            });
        }
        NSPBackgroundRefresh.request = request;
    })(NSPBackgroundRefresh || (NSPBackgroundRefresh = {}));
    let NSPEvent;
    (function (NSPEvent) {
        let status = Status.Undetermined;
        function typeFromString(value) {
            if (value === 'reminder') {
                return 1 /* EKEntityType.Reminder */;
            }
            else {
                return 0 /* EKEntityType.Event */;
            }
        }
        function getStatus(type) {
            const eventStatus = EKEventStore.authorizationStatusForEntityType(typeFromString(type));
            switch (eventStatus) {
                case 3 /* EKAuthorizationStatus.Authorized */:
                    status = Status.Authorized;
                    break;
                case 2 /* EKAuthorizationStatus.Denied */:
                    status = Status.Denied;
                    break;
                case 1 /* EKAuthorizationStatus.Restricted */:
                    status = Status.Restricted;
                    break;
                default:
                    status = Status.Undetermined;
            }
            return [status, true];
        }
        NSPEvent.getStatus = getStatus;
        function request(type) {
            return new Promise((resolve) => {
                const aStore = EKEventStore.new();
                aStore.requestAccessToEntityTypeCompletion(typeFromString(type), () => resolve(getStatus(type)));
            });
        }
        NSPEvent.request = request;
    })(NSPEvent || (NSPEvent = {}));
    let NSType;
    (function (NSType) {
        NSType["Location"] = "location";
        NSType["Camera"] = "camera";
        NSType["Microphone"] = "microphone";
        NSType["Photo"] = "photo";
        NSType["Contacts"] = "contacts";
        NSType["Event"] = "event";
        NSType["Reminder"] = "reminder";
        NSType["Bluetooth"] = "bluetooth";
        NSType["Notification"] = "notification";
        NSType["BackgroundRefresh"] = "backgroundRefresh";
        NSType["NSPTypeSpeechRecognition"] = "speechRecognition";
        NSType["MediaLibrary"] = "mediaLibrary";
        NSType["Motion"] = "motion";
    })(NSType = PermissionsIOS.NSType || (PermissionsIOS.NSType = {}));
    function openSettings() {
        return new Promise(async (resolve, reject) => {
            if (!(await canOpenSettings())) {
                reject(new Error('cant_open_settings'));
            }
            let timeoutHandler;
            function onActive(notif) {
                resolve(true);
                Application.ios.removeNotificationObserver(observer, UIApplicationDidBecomeActiveNotification);
                if (timeoutHandler) {
                    clearTimeout(timeoutHandler);
                    timeoutHandler = null;
                }
            }
            function onResignActive(notif) {
                Application.ios.removeNotificationObserver(observer1, UIApplicationWillResignActiveNotification);
                if (timeoutHandler) {
                    clearTimeout(timeoutHandler);
                    timeoutHandler = null;
                }
            }
            const observer = Application.ios.addNotificationObserver(UIApplicationDidBecomeActiveNotification, onActive);
            const observer1 = Application.ios.addNotificationObserver(UIApplicationWillResignActiveNotification, onResignActive);
            UIApplication.sharedApplication.openURLOptionsCompletionHandler(NSURL.URLWithString(UIApplicationOpenSettingsURLString), null, null);
            timeoutHandler = setTimeout(() => {
                Application.ios.removeNotificationObserver(observer, UIApplicationDidBecomeActiveNotification);
                Application.ios.removeNotificationObserver(observer1, UIApplicationWillResignActiveNotification);
                timeoutHandler = null;
                // something did not work let s cancel
                reject(new Error('cant_open_settings'));
            }, 1000);
        });
    }
    PermissionsIOS.openSettings = openSettings;
    async function canOpenSettings() {
        return !!UIApplicationOpenSettingsURLString;
    }
    PermissionsIOS.canOpenSettings = canOpenSettings;
    async function getPermissionStatus(type, json) {
        let status;
        if (Trace.isEnabled()) {
            CLog(CLogTypes.info, 'getPermissionStatus', type, json);
        }
        switch (type) {
            case NSType.Location: {
                // NSString *locationPermissionType = [RCTConvert NSString:json];
                status = NSPLocation.getStatusForType(json);
                break;
            }
            case NSType.Camera:
                status = NSPAudioVideo.getStatus('video');
                break;
            case NSType.Microphone:
                status = NSPAudioVideo.getStatus('audio');
                break;
            case NSType.Photo:
                status = NSPPhoto.getStatus();
                break;
            case NSType.Contacts:
                status = NSPContacts.getStatus();
                break;
            case NSType.Event:
                status = NSPEvent.getStatus('event');
                break;
            case NSType.Reminder:
                status = NSPEvent.getStatus('reminder');
                break;
            case NSType.Bluetooth:
                status = NSPBluetooth.getStatus();
                break;
            case NSType.Notification:
                status = await NSPNotification.getStatus();
                break;
            case NSType.BackgroundRefresh:
                status = NSPBackgroundRefresh.getStatus();
                break;
            case NSType.NSPTypeSpeechRecognition:
                status = NSPSpeechRecognition.getStatus();
                break;
            case NSType.MediaLibrary:
                status = NSPMediaLibrary.getStatus();
                break;
            case NSType.Motion:
                status = NSPMotion.getStatus();
                break;
            default:
                break;
        }
        return status;
    }
    PermissionsIOS.getPermissionStatus = getPermissionStatus;
    function requestPermission(type, json) {
        if (Trace.isEnabled()) {
            CLog(CLogTypes.info, 'requestPermission', type, json);
        }
        switch (type) {
            case NSType.Location:
                return NSPLocation.request(json);
            case NSType.Camera:
                return NSPAudioVideo.request('video');
            case NSType.Microphone:
                return NSPAudioVideo.request('audio');
            case NSType.Photo:
                return NSPPhoto.request();
            case NSType.Contacts:
                return NSPContacts.request();
            case NSType.Event:
                return NSPEvent.request('event');
            case NSType.Reminder:
                return NSPEvent.request('reminder');
            case NSType.Bluetooth:
                return NSPBluetooth.request();
            case NSType.Notification:
                let types;
                const typeStrings = json;
                const osVersion = parseFloat(Device.osVersion);
                if (osVersion >= 10) {
                    if (typeStrings.indexOf('alert') !== -1) {
                        types = types | 4 /* UNAuthorizationOptions.Alert */;
                    }
                    if (typeStrings.indexOf('badge') !== -1) {
                        types = types | 1 /* UNAuthorizationOptions.Badge */;
                    }
                    if (typeStrings.indexOf('sound') !== -1) {
                        types = types | 2 /* UNAuthorizationOptions.Sound */;
                    }
                    if (typeStrings.indexOf('carPlay') !== -1) {
                        types = types | 8 /* UNAuthorizationOptions.CarPlay */;
                    }
                    if (osVersion >= 12) {
                        if (typeStrings.indexOf('providesAppNotificationSettings') !== -1) {
                            types = types | 32 /* UNAuthorizationOptions.ProvidesAppNotificationSettings */;
                        }
                        if (typeStrings.indexOf('criticalAlert') !== -1) {
                            types = types | 16 /* UNAuthorizationOptions.CriticalAlert */;
                        }
                        if (typeStrings.indexOf('provisional') !== -1) {
                            types = types | 64 /* UNAuthorizationOptions.Provisional */;
                        }
                        if (osVersion >= 13 && osVersion <= 15) {
                            if (typeStrings.indexOf('annoucement') !== -1) {
                                types = types | 128 /* UNAuthorizationOptions.Announcement */;
                            }
                            if (typeStrings.indexOf('timeSensitive') !== -1) {
                                types = types | 256 /* UNAuthorizationOptions.TimeSensitive */;
                            }
                        }
                    }
                }
                else {
                    if (typeStrings.indexOf('alert') !== -1) {
                        types = types | 4 /* UIUserNotificationType.Alert */;
                    }
                    if (typeStrings.indexOf('badge') !== -1) {
                        types = types | 1 /* UIUserNotificationType.Badge */;
                    }
                    if (typeStrings.indexOf('sound') !== -1) {
                        types = types | 2 /* UIUserNotificationType.Sound */;
                    }
                }
                return NSPNotification.request(types);
            case NSType.NSPTypeSpeechRecognition:
                return NSPSpeechRecognition.request();
            case NSType.MediaLibrary:
                return NSPMediaLibrary.request();
            case NSType.Motion:
                return NSPMotion.request();
            default:
                return Promise.reject('unknown');
        }
    }
    PermissionsIOS.requestPermission = requestPermission;
})(PermissionsIOS || (PermissionsIOS = {}));
const DEFAULTS = {
    location: 'whenInUse',
    notification: ['alert', 'badge', 'sound']
};
const permissionTypes = Object.values(PermissionsIOS.NSType);
export function canOpenSettings() {
    return PermissionsIOS.canOpenSettings();
}
export function openSettings() {
    return PermissionsIOS.openSettings();
}
export function openNotificationSettings() {
    return PermissionsIOS.canOpenSettings();
}
export function getTypes() {
    return permissionTypes;
}
export async function check(permission, options) {
    if (Trace.isEnabled()) {
        CLog(CLogTypes.info, 'check', permission, options);
    }
    if (permissionTypes.indexOf(permission) === -1) {
        if (Trace.isEnabled()) {
            CLog(CLogTypes.warning, permission, 'is not a valid permission type on iOS');
        }
        return [PermissionsIOS.Status.Authorized, true];
    }
    let type;
    if (typeof options === 'string') {
        type = options;
    }
    else if (options && options.type) {
        type = options.type;
    }
    return PermissionsIOS.getPermissionStatus(permission, type || DEFAULTS[permission]);
}
export async function request(permission, options) {
    if (Trace.isEnabled()) {
        CLog(CLogTypes.info, 'request', permission, options);
    }
    if (typeof permission === 'object') {
        const grantedPermissions = {};
        const keys = Object.keys(permission);
        for (let index = 0; index < keys.length; index++) {
            const perm = keys[index];
            const res = await request(perm, permission[perm]);
            grantedPermissions[perm] = res[0];
        }
        //@ts-ignore
        return grantedPermissions;
    }
    if (permissionTypes.indexOf(permission) === -1) {
        if (Trace.isEnabled()) {
            CLog(CLogTypes.warning, permission, 'is not a valid permission type on iOS');
        }
        //@ts-ignore
        return [PermissionsIOS.Status.Authorized, true];
    }
    //@ts-ignore
    if (permission === 'backgroundRefresh') {
        throw new Error('@nativescript-community/perms: You cannot request backgroundRefresh');
    }
    let type;
    if (typeof options === 'string') {
        type = options;
    }
    else if (options && options.type) {
        type = options.type;
    }
    //@ts-ignore
    return PermissionsIOS.requestPermission(permission, type || DEFAULTS[permission]);
}
export function checkMultiple(permissions) {
    if (Trace.isEnabled()) {
        CLog(CLogTypes.info, 'checkMultiple', permissions);
    }
    return Promise.all(Object.keys(permissions).map((permission) => check(permission, permissions[permission]).then((r) => [permission, r]))).then((result) => result.reduce((acc, value, index) => {
        acc[value[0]] = value[1][0];
        return acc;
    }, {}));
}
//# sourceMappingURL=index.ios.js.map