import { Device, Frame, ImageAsset, ImageSource, Trace, Utils } from '@nativescript/core';
import * as permissions from '@nativescript-community/perms';
import { combineCamerPhotoPermissions, mapCameraPermissionStatus, mapError, mapPhotoPermissionStatus } from './common';
var UIImagePickerControllerDelegateImpl = /** @class */ (function (_super) {
    __extends(UIImagePickerControllerDelegateImpl, _super);
    function UIImagePickerControllerDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UIImagePickerControllerDelegateImpl.new = function () {
        return _super.new.call(this);
    };
    UIImagePickerControllerDelegateImpl.prototype.initWithCallback = function (callback, errorCallback) {
        this._callback = callback;
        this._errorCallback = errorCallback;
        return this;
    };
    UIImagePickerControllerDelegateImpl.prototype.initWithCallbackAndOptions = function (callback, errorCallback, options) {
        this._callback = callback;
        this._errorCallback = errorCallback;
        if (options) {
            this._width = options.width;
            this._height = options.height;
            this._saveToGallery = options.saveToGallery;
            this._allowsEditing = options.allowsEditing;
            this._keepAspectRatio = Utils.isNullOrUndefined(options.keepAspectRatio) ? true : options.keepAspectRatio;
        }
        return this;
    };
    UIImagePickerControllerDelegateImpl.prototype.imagePickerControllerDidFinishPickingMediaWithInfo = function (picker, info) {
        var _this = this;
        if (info) {
            var currentDate_1 = new Date();
            var source = info.valueForKey(UIImagePickerControllerOriginalImage);
            if (this._allowsEditing) {
                source = info.valueForKey(UIImagePickerControllerEditedImage);
            }
            if (source) {
                var imageSourceResult_1 = new ImageSource(source);
                if (this._callback) {
                    var imageAsset_1;
                    if (this._saveToGallery) {
                        PHPhotoLibrary.sharedPhotoLibrary().performChangesCompletionHandler(function () {
                            PHAssetChangeRequest.creationRequestForAssetFromImage(imageSourceResult_1.ios);
                        }, function (success, err) {
                            if (success) {
                                var fetchOptions = PHFetchOptions.alloc().init();
                                var sortDescriptors = NSArray.arrayWithObject(NSSortDescriptor.sortDescriptorWithKeyAscending('creationDate', false));
                                fetchOptions.sortDescriptors = sortDescriptors;
                                fetchOptions.predicate = NSPredicate.predicateWithFormatArgumentArray('mediaType = %d', NSArray.arrayWithObject(PHAssetMediaType.Image));
                                var fetchResult = PHAsset.fetchAssetsWithOptions(fetchOptions);
                                if (fetchResult.count > 0) {
                                    // Take last picture
                                    var asset = fetchResult.objectAtIndex(0);
                                    var dateDiff = asset.creationDate.valueOf() - currentDate_1.valueOf();
                                    if (Math.abs(dateDiff) > 1000) {
                                        // Image assets create date is rounded when asset is created.
                                        // Display waring if the asset was created more than 1s before/after the current date.
                                        console.warn('Image asset returned was created more than 1 second ago');
                                    }
                                    imageAsset_1 = new ImageAsset(asset);
                                    _this.setImageAssetAndCallCallback(imageAsset_1);
                                }
                            }
                            else {
                                Trace.write('An error ocurred while saving image to gallery: ' + err, Trace.categories.Error, Trace.messageType.error);
                            }
                        });
                    }
                    else {
                        imageAsset_1 = new ImageAsset(imageSourceResult_1.ios);
                        this.setImageAssetAndCallCallback(imageAsset_1);
                    }
                }
            }
        }
        picker.presentingViewController.dismissViewControllerAnimatedCompletion(true, null);
        listener = null;
    };
    UIImagePickerControllerDelegateImpl.prototype.setImageAssetAndCallCallback = function (imageAsset) {
        if (this._keepAspectRatio) {
            var pictureWidth = imageAsset.nativeImage ? imageAsset.nativeImage.size.width : imageAsset.ios.pixelWidth;
            var pictureHeight = imageAsset.nativeImage ? imageAsset.nativeImage.size.height : imageAsset.ios.pixelHeight;
            var isPictureLandscape = pictureWidth > pictureHeight;
            var areOptionsLandscape = this._width > this._height;
            if (isPictureLandscape !== areOptionsLandscape) {
                var oldWidth = this._width;
                this._width = this._height;
                this._height = oldWidth;
            }
        }
        imageAsset.options = {
            width: this._width,
            height: this._height,
            keepAspectRatio: this._keepAspectRatio,
        };
        this._callback(imageAsset);
    };
    UIImagePickerControllerDelegateImpl.prototype.imagePickerControllerDidCancel = function (picker) {
        picker.presentingViewController.dismissViewControllerAnimatedCompletion(true, null);
        listener = null;
        this._errorCallback(new Error('cancelled'));
    };
    UIImagePickerControllerDelegateImpl.ObjCProtocols = [UIImagePickerControllerDelegate];
    return UIImagePickerControllerDelegateImpl;
}(NSObject));
let listener;
export let takePicture = function (options) {
    return new Promise((resolve, reject) => {
        listener = null;
        let imagePickerController = UIImagePickerController.new();
        let reqWidth = 0;
        let reqHeight = 0;
        let keepAspectRatio = true;
        let saveToGallery = true;
        let allowsEditing = false;
        let modalPresentationStyle = 0 /* UIModalPresentationStyle.FullScreen */;
        if (options) {
            reqWidth = options.width || 0;
            reqHeight = options.height || reqWidth;
            keepAspectRatio = Utils.isNullOrUndefined(options.keepAspectRatio) ? keepAspectRatio : options.keepAspectRatio;
            saveToGallery = Utils.isNullOrUndefined(options.saveToGallery) ? saveToGallery : options.saveToGallery;
            allowsEditing = Utils.isNullOrUndefined(options.allowsEditing) ? allowsEditing : options.allowsEditing;
            if (typeof options.modalPresentationStyle === 'number') {
                modalPresentationStyle = options.modalPresentationStyle;
            }
        }
        let authStatus;
        if (parseFloat(Device.osVersion) >= 14) {
            authStatus = PHPhotoLibrary.authorizationStatusForAccessLevel(2 /* PHAccessLevel.ReadWrite */);
        }
        else {
            authStatus = PHPhotoLibrary.authorizationStatus();
        }
        if (authStatus !== 3 /* PHAuthorizationStatus.Authorized */ && authStatus !== 4 /* PHAuthorizationStatus.Limited */) {
            saveToGallery = false;
        }
        if (reqWidth && reqHeight) {
            listener = UIImagePickerControllerDelegateImpl.new().initWithCallbackAndOptions(resolve, reject, { width: reqWidth, height: reqHeight, keepAspectRatio: keepAspectRatio, saveToGallery: saveToGallery, allowsEditing: allowsEditing });
        }
        else if (saveToGallery || keepAspectRatio) {
            listener = UIImagePickerControllerDelegateImpl.new().initWithCallbackAndOptions(resolve, reject, { saveToGallery: saveToGallery, keepAspectRatio: keepAspectRatio, allowsEditing: allowsEditing });
        }
        else {
            listener = UIImagePickerControllerDelegateImpl.new().initWithCallback(resolve, reject);
        }
        imagePickerController.delegate = listener;
        let sourceType = 1 /* UIImagePickerControllerSourceType.Camera */;
        let mediaTypes = UIImagePickerController.availableMediaTypesForSourceType(sourceType);
        let imageMediaType = 'public.image';
        if (mediaTypes && mediaTypes.containsObject(imageMediaType)) {
            let mediaTypesArray = new NSMutableArray({ capacity: 1 });
            mediaTypesArray.addObject(imageMediaType);
            imagePickerController.mediaTypes = mediaTypesArray;
            imagePickerController.sourceType = sourceType;
            imagePickerController.cameraDevice = options && options.cameraFacing === 'front' ? 1 /* UIImagePickerControllerCameraDevice.Front */ : 0 /* UIImagePickerControllerCameraDevice.Rear */;
            imagePickerController.allowsEditing = allowsEditing;
        }
        imagePickerController.modalPresentationStyle = modalPresentationStyle;
        let topMostFrame = Frame.topmost();
        if (topMostFrame) {
            let viewController = topMostFrame.currentPage && topMostFrame.currentPage.ios;
            if (viewController) {
                while (viewController.parentViewController) {
                    // find top-most view controler
                    viewController = viewController.parentViewController;
                }
                while (viewController.presentedViewController) {
                    // find last presented modal
                    viewController = viewController.presentedViewController;
                }
                viewController.presentViewControllerAnimatedCompletion(imagePickerController, true, null);
            }
        }
    });
};
export let isAvailable = function () {
    return UIImagePickerController.isSourceTypeAvailable(1 /* UIImagePickerControllerSourceType.Camera */);
};
export let requestPermissions = function () {
    return requestCameraPermissions().then((cameraPermissions) => requestPhotosPermissions().then((photoPermissions) => combineCamerPhotoPermissions(cameraPermissions, photoPermissions)));
};
export let requestPhotosPermissions = function () {
    return permissions
        .request('photo')
        .then((photoPermissions) => mapPhotoPermissionStatus(photoPermissions))
        .catch((e) => mapError(e));
};
export let requestCameraPermissions = function () {
    return permissions
        .request('camera')
        .then((photoPermissions) => mapCameraPermissionStatus(photoPermissions))
        .catch((e) => mapError(e));
};
//# sourceMappingURL=index.ios.js.map